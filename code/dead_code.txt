%% User Inputs
%ICs = [0; 0; deg2rad(180); 0];
newICs = [0; 0; deg2rad(0); 0];
%oldICs = [0; 0; deg2rad(180); 0];

%% Linear EOM Simulation - Newtonian Dynamics Model
% Old Dynamics Model
% I = (1./3).*m.*L.*L;
% denom = (I.*(M+m)) + (M.*m.*(L.^2));
% A11 = 1;
% A22 = (-1.*(I+(m.*(L.^2))).*b)./denom;
% A23 = ((m.^2).*g.*(L.^2))./denom;
% A34 = 1;
% A42 = -1.*(m.*L.*b)./denom;
% A43 = (m.*g.*L.*(M+m))./denom;
% A = zeros(4);
% A(1,2) = A11;
% A(2,2) = A22;
% A(2,3) = A23;
% A(3,4) = A34;
% A(4,2) = A42;
% A(4,3) = A43;
% 
% % B Matrix
% B21 = (I+(m.*(L.^2)))./denom;
% B41 = (m.*L)/denom;
% B = zeros(4,1);
% B(2,1) = B21;
% B(4,1) = B41;

% C Matrix
%C = zeros(2, 4);
%C(1,1) = 1;
%C(2,3) = 1;
C = eye(4);

% D Matrix
%D = zeros(2,1);
D = zeros(4, 1);


% New Dynamics Model
A = zeros(4);
A(1,2) = 1;
A(2,2) = (b)./((2*m)+M);
A(2,3) = (m*g)./((2*m)+M);
A(3,4) = 1;
A(4,2) = (-1.*b)./(L.*((2*m)+M));
A(4,3) = (g./L) - ((m*g)./((2*m)+M));

% B Matrix
B = zeros(4,1);
B(2,1) = (1)./((2*m)+M);
B(4,1) = (-1)./(L.*((2*m)+M));

% C Matrix
%C = zeros(2, 4);
%C(1,1) = 1;
%C(2,3) = 1;
C = eye(4);

% D Matrix
%D = zeros(2,1);
D = zeros(4, 1);

% % Create a Matlab State Space Model
% ogLinSys = ss(A,B,C,D);
stepInput = genStepInput(timeVec, stepTime, stepAmp);
% [yOld, tOld] = lsim(ogLinSys, stepInput, timeVec, oldICs);

% newLinSys = ss(A, B, C, D);
% [yNew, tNew] = lsim(newLinSys, stepInput, timeVec, newICs);

% [yOld, tOld] = lsim(ogLinSys, stepInput, timeVec, oldICs);

% newLinSys = ss(A, B, C, D);
% [yNew, tNew] = lsim(newLinSys, stepInput, timeVec, newICs);

%% Sim with ODE45
state_0 = [0; 0; deg2rad(0); 0];

massPen = 0.35;
massCart = 2.2;
lenRod = 1.3;
cartFriction = 0.25;
grav = -9.8;

% Define Sim Time
tSpan = 0:1E-1:4;

% [tNew, yNew] = ode45(@(t, state) invPenCartEoM(t, state, massPen, massCart, lenRod,...
%     cartFriction, grav, @unitImpulse, [0; 0; deg2rad(0); 0], transpose(K)), tSpan, state_0);



[yNew, tNew] = lsim(closeLoopSysPolePlace, stepInput, timeVec, newICs);


plot(tNew, yNew(:, 3))

yStore = NaN(size(yNew, 1), 5);
for ii = 1:1:size(yNew, 1)
    yStore(ii, 1) = tNew(ii);
    yStore(ii, 2:5) = [0, 0, pi./2, 0] + yNew(ii, :);
end

figure()
plot(tNew, yNew(:, 3))

massPen = 0.35;
massCart = 2.2;
lenRod = 1.3;
cartFriction = 0.25;
figure(2)
for k=1:length(tNew)
    drawpend(yNew(k,:), massPen, massCart, lenRod);
end

%% Helper Functions
function [dState] = invPenCartEoM(t, state, massPen, massCart, lenRod,...
    cartFriction, grav, d, refState, gain)

    dAccel = feval(d, t);

    %u = -gain.*(state - refState);
    u = refState - gain.*state;

    % A Matrix
    A = zeros(4);
    A(1,2) = 1;
    A(2,2) = (cartFriction)./((2*massPen)+massCart);
    A(2,3) = (massPen*grav)./((2*massPen)+massCart);
    A(3,4) = 1;
    A(4,2) = (-1.*cartFriction)./(lenRod.*((2*massPen)+massCart));
    A(4,3) = (grav./lenRod) - ((massPen*grav)./((2*massPen)+massCart));

    % B Matrix
    B = zeros(4,1);
    B(2,1) = (1)./((2*massPen)+massCart);
    B(4,1) = (-1)./(lenRod.*((2*massPen)+massCart));

    % A = [0, 1, 0, 0;...
    %     0, -1./massCart, massPen.*grav./massCart, 0;...
    %     0, 0, 0, 1;...
    %     0, 1./(massCart*lenRod), (massCart+massPen).*grav./(massCart*lenRod), 0];
    % 
    % B = [0; 1/massCart; 0; 1/(massCart*lenRod)];


    % F Matrix
    F = zeros(4, 1);
    F(2, 1) = 1;

    dState = A*state + B.*u + F.*dAccel;
    
    % cosTheta = cos(state(3));
    % sinTheta = sin(state(3));
    % 
    % % Compute Common Denominator
    % temp = cosTheta;
    % temp = temp.^2;
    % temp = 1 - temp;
    % temp = massPen.*temp;
    % temp = massCart + temp;
    % denom = massPen.*(lenRod.^2).*temp;
    % 
    % % Differential Equations of Motion
    % dState = NaN(size(state));
    % 
    % % x dot - linear velocity
    % dState(1) = state(2);
    % 
    % % x double dot - linear acceleration
    % one = -1.*(massPen.^2).*(lenRod.^2).*grav.*cosTheta.*sinTheta;
    % two = massPen.*lenRod.*(state(4).^2).*sinTheta;
    % two = two - (cartFriction.*state(2));
    % two = (massPen.*(lenRod.^2)).*two;
    % three = massPen.*(lenRod.^2).*u;
    % num = one + two + three;
    % dState(2) = num./denom;
    % dState(2) = dState(2) + dAccel;
    % 
    % % theta dot - angular velocity
    % dState(3) = state(4);
    % 
    % % theta double dot - angular acceleration
    % one = (massPen+massCart).*(massPen.*grav.*lenRod.*sinTheta);
    % two = massPen.*lenRod.*(state(4).^2).*sinTheta;
    % two = two - (cartFriction.*state(2));
    % two = (massPen.*lenRod.*cosTheta).*two;
    % three = massPen.*lenRod.*cosTheta.*u;
    % num = one - two +  three;
    % dState(4) = num./denom;
end

% This analysis shows the comparison of the Pole Placement Method and LQR
% Method for the Close-Loop Controller with the Disturbance Plot

% Step Response
[yOpenStep, tOpenStep] = lsim(linSys, stepInput, timeVec, ICs);
[yClosePoleStep, tClosePoleStep] = lsim(closeLoopSysPolePlace, stepInput,...
    timeVec, ICs);

figure()
scatter(timeVec, stepInput)
grid on
xlabel('Time [sec]')
ylabel('Response')
title('Step Response')

figure();
title('Step Response')
subplot(4, 1, 1)
hold on
plot(tOpenStep, yOpenStep(:, 1), 'k')
plot(tClosePoleStep, yClosePoleStep(:, 1), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Position [m]')

subplot(4, 1, 2)
hold on
plot(tOpenStep, yOpenStep(:, 2), 'k')
plot(tClosePoleStep, yClosePoleStep(:, 2), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Velocity [m/s]')

subplot(4, 1, 3)
hold on
plot(tOpenStep, yOpenStep(:, 3), 'k')
plot(tClosePoleStep, yClosePoleStep(:, 3), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Angle [deg]')

subplot(4, 1, 4)
hold on
plot(tOpenStep, yOpenStep(:, 3), 'k')
plot(tClosePoleStep, yClosePoleStep(:, 3), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Angle Rate [deg/sec]')

% Impule Response
impulseInput = genImpulseInput(timeVec, 1, impulseAmp);
[yOpenImpulse, tOpenImpulse] = lsim(linSys, impulseInput, timeVec, ICs);
[yClosePoleImpulse, tClosePoleImpulse] = lsim(closeLoopSysPolePlace, impulseInput,...
    timeVec, ICs);

figure()
scatter(timeVec, impulseInput)
grid on
xlabel('Time [sec]')
ylabel('Response')
title('Impulse Response')

figure();
title('Step Response')
subplot(4, 1, 1)
hold on
plot(tOpenImpulse, yOpenImpulse(:, 1), 'k')
plot(tClosePoleImpulse, yClosePoleImpulse(:, 1), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Position [m]')

subplot(4, 1, 2)
hold on
plot(tOpenImpulse, yOpenImpulse(:, 2), 'k')
plot(tClosePoleImpulse, yClosePoleImpulse(:, 2), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Velocity [m/s]')

subplot(4, 1, 3)
hold on
plot(tOpenImpulse, yOpenImpulse(:, 3), 'k')
plot(tClosePoleImpulse, yClosePoleImpulse(:, 3), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Angle [deg]')

subplot(4, 1, 4)
hold on
plot(tOpenImpulse, yOpenImpulse(:, 3), 'k')
plot(tClosePoleImpulse, yClosePoleImpulse(:, 3), 'b')
hold off
grid on
xlabel('Time [s]')
ylabel('Angle Rate [deg/sec]')
